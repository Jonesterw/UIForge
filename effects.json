[{ "id": "magnetic-hover-effect",
    "title": "Magnetic Hover Effect",
    "category": "js",
    "description": "A card that follows the cursor slightly, creating a magnetic effect.",
    "author": "Jonesterw",
    "link": "#",
    "tags": ["js", "hover", "magnetic", "interactive"],
    "explanation": "This effect uses JavaScript to move the card toward the cursor on hover, creating a magnetic attraction.",
    "html": "<div class=\"magnetic-card\">Magnetic</div>",
    "css": ".magnetic-card {\n  width: 220px;\n  height: 140px;\n  background: #181f2b;\n  color: #fff;\n  border-radius: 16px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 1.5rem;\n  box-shadow: 0 4px 24px rgba(0,0,0,0.3);\n  transition: transform 0.4s cubic-bezier(0.23, 1, 0.32, 1);\n  will-change: transform;\n  cursor: pointer;\n}\n",
    "js": "function initMagneticHoverEffect(container) {\n  const card = container.querySelector('.magnetic-card');\n  if (!card) return;\n\n  function onMove(e) {\n    const rect = card.getBoundingClientRect();\n    const x = e.clientX - rect.left - rect.width / 2;\n    const y = e.clientY - rect.top - rect.height / 2;\n\n    const translateX = x * 0.3;\n    const translateY = y * 0.3;\n    const rotateX = -y * 0.08;\n    const rotateY = x * 0.08;\n\n    card.style.transform = `perspective(800px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translate(${translateX}px, ${translateY}px)`;\n  }\n\n  function onLeave() {\n    card.style.transform = '';\n  }\n\n  container.addEventListener('mousemove', onMove);\n  container.addEventListener('mouseleave', onLeave);\n\n  return () => {\n    container.removeEventListener('mousemove', onMove);\n    container.removeEventListener('mouseleave', onLeave);\n    card.style.transform = '';\n  };\n}\nwindow.initMagneticHoverEffect = initMagneticHoverEffect;"
  },
  {
    "id": "confetti-burst-effect",
    "title": "Confetti Burst Card",
    "category": "js",
    "description": "A card that bursts confetti particles when clicked.",
    "author": "Jonesterw",
    "link": "#",
    "tags": ["js", "confetti", "interactive", "click"],
    "explanation": "This effect uses JavaScript to create a confetti burst animation on click.",
    "html": "<div class=\"confetti-card\">Click for Confetti!<canvas class=\"confetti-canvas\"></canvas></div>",
    "css": ".confetti-card {\n  position: relative;\n  width: 220px;\n  height: 140px;\n  background: #2d1e4a;\n  color: #fff;\n  border-radius: 16px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 1.2rem;\n  box-shadow: 0 4px 24px rgba(0,0,0,0.3);\n  cursor: pointer;\n  overflow: hidden;\n}\n.confetti-canvas {\n  position: absolute;\n  top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;\n}\n",
    "js": "function initConfettiBurstEffect(container) {\n  const card = container.querySelector('.confetti-card');\n  if (!card) return;\n  const canvas = card.querySelector('.confetti-canvas');\n  if (!canvas) return;\n  const ctx = canvas.getContext('2d');\n  let animationFrameId;\n\n  // Use ResizeObserver for performant and scoped resize handling\n  const resize = () => {\n    if (!card.isConnected) return;\n    canvas.width = card.offsetWidth;\n    canvas.height = card.offsetHeight;\n  };\n  const resizeObserver = new ResizeObserver(resize);\n  resizeObserver.observe(card);\n  resize(); // Initial size\n\n  function burst() {\n    // Cancel any ongoing animation from a previous click\n    if (animationFrameId) {\n      cancelAnimationFrame(animationFrameId);\n    }\n\n    const confetti = [];\n    const particleCount = 40;\n    const durationFrames = 90;\n\n    for (let i = 0; i < particleCount; i++) {\n      confetti.push({\n        x: canvas.width / 2,\n        y: canvas.height / 2,\n        r: Math.random() * 6 + 4,\n        color: `hsl(${Math.random() * 360}, 90%, 60%)`,\n        vx: Math.cos(Math.random() * 2 * Math.PI) * Math.random() * 6,\n        vy: Math.sin(Math.random() * 2 * Math.PI) * Math.random() * 6 - 2,\n        alpha: 1,\n      });\n    }\n\n    let frame = 0;\n    function draw() {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      confetti.forEach((p) => {\n        p.x += p.vx;\n        p.y += p.vy;\n        p.vy += 0.15; // gravity\n        p.alpha -= 1 / durationFrames; // fade out over the animation duration\n\n        if (p.alpha > 0) {\n          ctx.globalAlpha = p.alpha;\n          ctx.beginPath();\n          ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI);\n          ctx.fillStyle = p.color;\n          ctx.fill();\n        }\n      });\n\n      frame++;\n      if (frame < durationFrames) {\n        animationFrameId = requestAnimationFrame(draw);\n      } else {\n        animationFrameId = null; // Animation finished\n      }\n    }\n    draw();\n  }\n\n  card.addEventListener('click', burst);\n\n  // Return a cleanup function\n  return () => {\n    card.removeEventListener('click', burst);\n    resizeObserver.disconnect();\n    if (animationFrameId) {\n      cancelAnimationFrame(animationFrameId);\n    }\n  };\n}\nwindow.initConfettiBurstEffect = initConfettiBurstEffect;"
  },
  {
    "id": "animated-gradient-border",
    "title": "Animated Gradient Border",
    "category": "css",
    "description": "A card with a border that animates with a moving gradient.",
    "author": "Jonesterw",
    "link": "#",
    "tags": ["css", "gradient", "border", "animation"],
    "explanation": "This effect uses a nested div structure. The outer div has an animated gradient background and padding. The inner div has a solid background, creating the illusion of an animated border in the padded area.",
    "html": "<div class=\"gradient-border-card\"><div class=\"gradient-border-inner\">Animated Border</div></div>",
    "css": ".gradient-border-card {\n  width: 220px;\n  height: 140px;\n  padding: 3px;\n  border-radius: 18px;\n  background: linear-gradient(270deg, #ff6b6b, #f8e71c, #58a6ff, #e975a8, #ff6b6b);\n  background-size: 400% 400%;\n  animation: borderMove 4s linear infinite;\n}\n.gradient-border-inner {\n  width: 100%;\n  height: 100%;\n  background: #181f2b;\n  color: #fff;\n  border-radius: 15px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 1.2rem;\n}\n@keyframes borderMove {\n  0% { background-position: 0% 50%; }\n  100% { background-position: 100% 50%; }\n}\n",
    "js": ""
  },
  {
    "id": "typewriter-text-effect",
    "title": "Typewriter Text Card",
    "category": "js",
    "description": "A card where the text appears as if being typed out.",
    "author": "Jonesterw",
    "link": "#",
    "tags": ["js", "typewriter", "text", "animation"],
    "explanation": "This effect uses JavaScript to animate text as if being typed out, letter by letter.",
    "html": "<div class=\"typewriter-card\"><span class=\"typewriter-text\"></span></div>",
    "css": ".typewriter-card {\n  width: 220px;\n  height: 140px;\n  background: #1a2a3a;\n  color: #fff;\n  border-radius: 16px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 1.2rem;\n  box-shadow: 0 4px 24px rgba(0,0,0,0.3);\n  overflow: hidden;\n}\n.typewriter-text {\n  border-right: 2px solid #fff;\n  white-space: nowrap;\n  overflow: hidden;\n  display: inline-block;\n  animation: blink 1s steps(1) infinite;\n}\n@keyframes blink {\n  0%,100%{border-color:transparent;}\n  50%{border-color:#fff;}\n}\n",
  "js": "function initTypewriterTextEffect(container) {\n  const text = 'Typewriter Animation!';\n  const el = container.querySelector('.typewriter-text');\n  if (!el) return;\n  let i = 0, timeoutId;\n  function type() {\n    if (i <= text.length) {\n      el.textContent = text.slice(0, i++);\n      timeoutId = setTimeout(type, 80);\n    }\n  }\n  type();\n  // Return a cleanup function to be called on mouseleave\n  return () => {\n    clearTimeout(timeoutId);\n    el.textContent = '';\n  };\n}\nwindow.initTypewriterTextEffect = initTypewriterTextEffect;"
  },
  {
    "id": "expanding-search-bar",
    "title": "Expanding Search Bar",
    "category": "js",
    "description": "A search icon that expands into a full search bar on click.",
    "author": "Jonesterw",
    "link": "#",
    "tags": ["js", "css", "ui", "search", "interactive"],
    "explanation": "This UI component uses a small JavaScript snippet to toggle a CSS class on a container. The CSS then uses transitions to smoothly expand the width of the search bar and fade in the input field, creating a clean and space-saving search interface.",
    "html": "<div class=\"search-box\"><input class=\"search-input\" type=\"text\" placeholder=\"Search...\"><button class=\"search-btn\"><svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"11\" cy=\"11\" r=\"8\"></circle><line x1=\"21\" y1=\"21\" x2=\"16.65\" y2=\"16.65\"></line></svg></button></div>",
    "css": ".search-box {\n  position: relative;\n  width: 44px;\n  height: 44px;\n  background: #232946;\n  border-radius: 22px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: width 0.4s cubic-bezier(.22,1,.36,1);\n  box-shadow: 0 4px 24px rgba(0,0,0,0.18);\n}\n.search-box.active {\n  width: 240px;\n}\n.search-input {\n  box-sizing: border-box;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  border: none;\n  outline: none;\n  background: transparent;\n  color: #fff;\n  font-size: 1rem;\n  padding: 0 50px 0 20px;\n  opacity: 0;\n  pointer-events: none;\n  transition: opacity 0.3s ease;\n}\n.search-box.active .search-input {\n  opacity: 1;\n  pointer-events: auto;\n  transition-delay: 0.1s;\n}\n.search-btn {\n  position: absolute;\n  right: 0;\n  top: 0;\n  background: none;\n  border: none;\n  outline: none;\n  cursor: pointer;\n  width: 44px;\n  height: 44px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 2;\n  color: var(--primary-accent, #58a6ff);\n  transition: color 0.3s ease;\n}\n.search-box.active .search-btn {\n  color: var(--secondary-accent, #e975a8);\n}\n.search-btn svg {\n  display: block;\n}\n",
    "js": "function initExpandingSearchBar(container) {\n  const searchBox = container.querySelector('.search-box');\n  const searchBtn = container.querySelector('.search-btn');\n  const searchInput = container.querySelector('.search-input');\n  if (!searchBox || !searchBtn || !searchInput) return;\n\n  const toggleSearch = (e) => {\n    // Stop propagation to prevent card's mouseleave event from firing immediately\n    e.stopPropagation(); \n    searchBox.classList.toggle('active');\n    if (searchBox.classList.contains('active')) {\n      searchInput.focus();\n    }\n  };\n  \n  // Also close if the mouse leaves the entire preview area\n  const closeSearch = () => {\n    searchBox.classList.remove('active');\n  };\n\n  searchBtn.addEventListener('click', toggleSearch);\n  container.addEventListener('mouseleave', closeSearch);\n\n  return () => {\n    searchBtn.removeEventListener('click', toggleSearch);\n    container.removeEventListener('mouseleave', closeSearch);\n  };\n}\nwindow.initExpandingSearchBar = initExpandingSearchBar;"
  },
  {
    "id": "gooey-svg-loader",
    "title": "Gooey SVG Loader",
    "category": "css",
    "description": "A loading animation where circles merge and separate with a liquid-like effect.",
    "author": "Jonesterw",
    "link": "#",
    "tags": ["css", "svg", "loader", "animation", "filter"],
    "explanation": "This effect uses an SVG filter (`feGaussianBlur` and `feColorMatrix`) to create a 'gooey' or 'metaball' effect. The CSS animates simple circles, but the SVG filter applied to their container makes their edges blend together when they get close, creating a liquid-like appearance.",
    "html": "<div class=\"gooey-loader-container\"><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" style=\"display:none\"><defs><filter id=\"gooey\"><feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"10\" result=\"blur\" /><feColorMatrix in=\"blur\" mode=\"matrix\" values=\"1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7\" result=\"goo\" /><feBlend in=\"SourceGraphic\" in2=\"goo\" /></filter></defs></svg><div class=\"gooey-dots\"><div class=\"dot\"></div><div class=\"dot\"></div><div class=\"dot\"></div></div></div>",
    "css": ".gooey-loader-container {\n  width: 150px;\n  height: 150px;\n  filter: url(#gooey);\n  position: relative;\n}\n.gooey-dots {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n.dot {\n  position: absolute;\n  width: 30px;\n  height: 30px;\n  background: var(--primary-accent, #58a6ff);\n  border-radius: 50%;\n  animation: gooey-move 3s ease-in-out infinite;\n  animation-play-state: paused;\n}\n.gooey-loader-container:hover .dot {\n  animation-play-state: running;\n}\n.dot:nth-child(1) { animation-delay: 0s; }\n.dot:nth-child(2) { animation-delay: -1s; }\n.dot:nth-child(3) { animation-delay: -2s; }\n@keyframes gooey-move {\n  0%, 100% { transform: translate(0, 0) scale(1); }\n  33% { transform: translate(40px, -40px) scale(0.8); }\n  66% { transform: translate(-40px, 40px) scale(1.2); }\n}\n",
    "js": ""
  },
  {
    "id": "interactive-particle-network",
    "title": "Interactive Particle Network",
    "category": "js",
    "description": "A dynamic network of particles that react to mouse movement.",
    "author": "Jonesterw",
    "link": "#",
    "tags": ["js", "canvas", "interactive", "particles", "generative"],
    "explanation": "This effect uses JavaScript and the HTML Canvas to render a field of particles. The script continuously updates particle positions and draws lines between nearby particles and the cursor, creating a dynamic, interactive web.",
    "html": "<canvas class=\"particle-network-canvas\"></canvas>",
    "css": ".particle-network-canvas {\n  display: block;\n  width: 100%;\n  height: 100%;\n  background: #0d1117;\n}\n",
    "js": "function initInteractiveParticleNetwork(container) {\n  const canvas = container.querySelector('.particle-network-canvas');\n  const ctx = canvas.getContext('2d');\n  if (!canvas) return;\n\n  // Helper function to limit the rate at which a function gets called.\n  function debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n      const later = () => { clearTimeout(timeout); func(...args); };\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  let animationFrameId;\n  let particles = [];\n  \n  const mouse = {\n    x: null,\n    y: null,\n  };\n\n  class Particle {\n    constructor(x, y, directionX, directionY, size) {\n      this.x = x;\n      this.y = y;\n      this.directionX = directionX;\n      this.directionY = directionY;\n      this.size = size;\n    }\n    draw() {\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);\n      ctx.fillStyle = 'rgba(88, 166, 255, 0.8)'; // var(--primary-accent)\n      ctx.fill();\n    }\n    update() {\n      if (this.x > canvas.width || this.x < 0) this.directionX = -this.directionX;\n      if (this.y > canvas.height || this.y < 0) this.directionY = -this.directionY;\n      this.x += this.directionX;\n      this.y += this.directionY;\n      this.draw();\n    }\n  }\n\n  function resizeCanvas() {\n    // Set canvas size to match its container's display size\n    canvas.width = container.offsetWidth;\n    canvas.height = container.offsetHeight;\n    initParticles();\n  }\n  \n  // Debounce resize to avoid performance issues\n  const debouncedResize = debounce(resizeCanvas, 100);\n  // Use ResizeObserver for better performance and reliability\n  const resizeObserver = new ResizeObserver(debouncedResize);\n  resizeObserver.observe(container);\n\n  // Initial resize\n  resizeCanvas();\n\n  // Mouse listeners\n  const onMouseMove = (event) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = event.clientX - rect.left;\n    mouse.y = event.clientY - rect.top;\n  };\n  const onMouseOut = () => {\n    mouse.x = null;\n    mouse.y = null;\n  };\n  container.addEventListener('mousemove', onMouseMove);\n  container.addEventListener('mouseout', onMouseOut);\n\n  function initParticles() {\n    particles = [];\n    // Increase particle density\n    let numberOfParticles = (canvas.height * canvas.width) / 3500;\n    for (let i = 0; i < numberOfParticles; i++) {\n      let size = (Math.random() * 1.5) + 1;\n      let x = (Math.random() * ((canvas.width - size * 2) - (size * 2)) + size * 2);\n      let y = (Math.random() * ((canvas.height - size * 2) - (size * 2)) + size * 2);\n      let directionX = (Math.random() * .4) - .2;\n      let directionY = (Math.random() * .4) - .2;\n      particles.push(new Particle(x, y, directionX, directionY, size));\n    }\n  }\n\n  function connect() {\n    const connectRadiusSq = Math.pow(Math.min(canvas.width, canvas.height) / 5, 2);\n    const mouseConnectRadiusSq = Math.pow(Math.min(canvas.width, canvas.height) / 3.5, 2);\n\n    // Connect particles to each other\n    for (let a = 0; a < particles.length; a++) {\n      for (let b = a; b < particles.length; b++) {\n        let distanceSq = Math.pow(particles[a].x - particles[b].x, 2) + Math.pow(particles[a].y - particles[b].y, 2);\n        \n        if (distanceSq < connectRadiusSq) {\n          const opacityValue = 1 - (distanceSq / connectRadiusSq);\n          ctx.strokeStyle = `rgba(140, 180, 255, ${opacityValue})`;\n          ctx.lineWidth = 0.5;\n          ctx.beginPath();\n          ctx.moveTo(particles[a].x, particles[a].y);\n          ctx.lineTo(particles[b].x, particles[b].y);\n          ctx.stroke();\n        }\n      }\n    }\n    // Connect particles to mouse\n    if (mouse.x !== null && mouse.y !== null) {\n      for (let i = 0; i < particles.length; i++) {\n        let distanceSq = Math.pow(particles[i].x - mouse.x, 2) + Math.pow(particles[i].y - mouse.y, 2);\n        \n        if (distanceSq < mouseConnectRadiusSq) {\n          const opacityValue = 1 - (distanceSq / mouseConnectRadiusSq);\n          ctx.strokeStyle = `rgba(233, 117, 168, ${opacityValue})`; // var(--secondary-accent)\n          ctx.lineWidth = 0.8;\n          ctx.beginPath();\n          ctx.moveTo(particles[i].x, particles[i].y);\n          ctx.lineTo(mouse.x, mouse.y);\n          ctx.stroke();\n        }\n      }\n    }\n  }\n\n  function animate() {\n    animationFrameId = requestAnimationFrame(animate);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    for (let i = 0; i < particles.length; i++) {\n      particles[i].update();\n    }\n    connect();\n  }\n  \n  animate();\n\n  return () => {\n    cancelAnimationFrame(animationFrameId);\n    resizeObserver.disconnect();\n    container.removeEventListener('mousemove', onMouseMove);\n    container.removeEventListener('mouseout', onMouseOut);\n  };\n}\nwindow.initInteractiveParticleNetwork = initInteractiveParticleNetwork;"
  }
]
